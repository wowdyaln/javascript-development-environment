- 025 - Demo - Sharing Work-in-progress
localtunnel 非常實用。如果您有一堆設備要與本地託管的工作進行對比，那麼將 **Browsersync** 與**localtunnel** 結合起來是一個非常有吸引力的組合。

  `npm install localtunnel -g`

---
- 032 - Demo - Concurrent Tasks
  - npm run all來並行執行在右側列出的所有任務
`npm start -s`

  - 為了方便起見，我想同時運行任務。我想要一個啟動Web服務器的命令，並通過本地通道共享我的工作，這樣我就不必像前一個模塊那樣手動打開兩個獨立的終端。
`npm run share`

---
### 41 why bundle?

NPM 使用 commonJS模式； node 可以處理這個，但瀏覽器不理解它。
 因此，您需要將NPM軟件包 bundle 到瀏覽器可以使用的格式中。
bundler 不僅僅適用於在瀏覽器中運行的應用程序。
 您可以使用 bundler 將任何 JavaScript 打包到單個文件中。
 或策略性地將其分成不同的文件，用於您應用的不同部分。
 想像一下你已經創建了一個包含五個獨立頁面的應用程序。
 一個強大的打包程序可以為每個頁面智能地創建單獨的JavaScript包。
 **這樣，用戶只需在初始加載時下載第一頁的相關JavaScript。**
 這可節省帶寬並加快頁面加載速度。
  - improve Node performance
bundler 不僅僅適用於Web。
 如果您在 node 中進行編碼，則可能需要使用捆綁器，因為 node 的 require很慢。 您可以編譯require請求，這通常可以提高性能。
我們先考慮JavaScript中提供的各種模塊格式，包括AMD，CommonJS，UMD和ES6模塊。

node.js 可以繼續使用CommonJS。
 但是，如果您在ES6或更新版本的JavaScript中工作，您終於可以享受ES6 module的強大功能。**而對於未來的應用開發，我們應該選擇ES6 module**。

---

- 049 - Sourcemaps

 一旦我們開始捆綁，縮小和編譯我們的代碼，我們就會產生一個新問題。
 當我們的代碼在瀏覽器中運行時，它變成了一個不可讀的混亂。
我該如何 debug ？另一個我們需要的重要工具：Sourcemaps。

生成一個源映射。Sourcemaps將捆綁，轉碼和縮小的代碼映射回原始源代碼。這意味著，當我們打開我們的瀏覽器開發工具並嘗試檢查我們的代碼時，我們會看到我們使用的原始ES6源代碼。這就像魔術一樣。源代碼可以作為我們構建過程的一部分自動生成。
您可能想知道如何縮小代碼實際上節省了任何帶寬，如果我們必須生成一個大的地圖回到原始來源。 源代碼的美妙之處在於，只有打開開發人員工具才能下載它們。
 因此，用戶甚至不會下載源代碼，但是在發生問題時，無論是在開發環境還是在生產環境中，它們都可供您使用。源代碼為您提供讀取原始代碼的所有好處，而不會給普通用戶帶來額外的成本。

 `devtool: 'inline-source-map'`
設置裡面這行，當我們在瀏覽器 debug， 可以看到原始碼，即使我們的代碼已經被轉換，捆綁和縮小之後。

---

### 63  why Lint via an automated build

您可能會想知道為什麼我們應該通過自動構建過程來 lint，因為許多編輯器都提供了ESLint集成內置的功能，所以他們只是監視您的代碼並在那裡輸出結果在編輯器內。我更願意將ESLint與我的構建過程集成在一起：首先，將我的代碼的所有反饋輸出到命令行，為我提供了一個地方來檢查與我的代碼質量相關的所有反饋。

 這意味著我有一個地方不僅可以查看linting問題，還可以查看任何編譯時錯誤或任何測試錯誤。
 **這對開發人員使用不同編輯器的團隊尤其有用。**
 我們都有相同的開發工作流程，因為我們都使用相同的入門工具包和命令行。
 如果每個人都有相同的開發流程，配對編程也更容易，而且最重要的是，ESLint應該是您的構建過程的一部分，以便在有人commit任何引發linting錯誤的代碼時，構建在持續集成服務器上被破壞。 這有助於防止您的應用程序慢慢變得不穩定。 即使開發人員在本地忽略ESLint，您的持續集成服務器也會自動拒絕構建。

---
### 70 Assertion library

許多測試框架如Jasmine和Jest都帶有內置的斷言。
 但是摩卡沒有提供斷言庫，所以我們必須選擇我們自己的。
 斷言庫之間的大多數選擇歸結為輕微的語法差異。
 最流行的斷言庫是Chai，但還有其他斷言庫，例如：Should.js ;  Expect。
 大多數框架都包含自己的內置斷言，但由於Mocha沒有，我們需要選擇一個。
 再一次，這些之間的核心區別是語法差異較小，所以不要花太多時間擔心這一點。
我們將使用Chai進行斷言，因為它很受歡迎，並提供了一系列斷言樣式可供選擇。

  - Helper library

在我們開始編寫測試之前，還有另一個問題需要回答。
 我們應該使用助手庫嗎？如果是這樣，哪一個？ 

    JSDOM是一個值得考慮的有趣的 library。
    JSDOM是您可以在Node中運行的瀏覽器DOM的實現。

 所以在JSDOM中，我們可以運行依賴於DOM的測試，而無需打開實際的瀏覽器。 這使得自動化測試的測試配置更簡單，並且通常意味著測試運行得更快。 所以當你想用Node編寫涉及HTML和瀏覽器交互的測試時，JSDOM很有用。

     Cheerio是值得一提的另一個有趣的library

 您可以將Cheerio視為服務器的jQuery。
 如果您使用JSDOM，這非常方便，因為您可以編寫測試來確定某個HTML是否符合您的期望。如果您了解jQuery，則您已經知道如何使用Cheerio，因為它使用jQuery選擇器來查詢DOM。 使用Cheerio，你可以使用jQuery的選擇器來查詢JSDOM的虛擬DOM。

 如果您已經了解jQuery，與編寫傳統的DOM查詢相比，這可以節省一些輸入。


### 72 Where to run test ?

 有三種流行的方法來運行基於JavaScript的測試。

       最明顯的選擇是在瀏覽器中運行我們的測試。
 Karma和Testem是流行的測試跑步者，用於在實際瀏覽器中進行測試。
 然而，打開一個實際的瀏覽器需要更多的配置，並且比替代選擇要慢，所以我寧願避免這種方法。


    我們可以使用像PhantomJS這樣的無頭瀏覽器來運行我們的測試。

 那麼什麼是無頭瀏覽器？無頭瀏覽器是沒有可見用戶界面的瀏覽器。
 PhantomJS是一個完全真實的瀏覽器，在後台運行V8 JavaScript引擎。
 但是你看不到PhantomJS，因為它沒有可見的界面。
 這很有用，因為經常編寫自動化測試你不需要看到實際的界面。 您只需要快速的模擬真實瀏覽器。

     第三種選擇是利用記憶體中的DOM。
 正如我們剛剛討論的，JSDOM是一個庫，它通過在我們可以與之交互的記憶體中創建一個DOM來模擬實際的瀏覽器。 您可以將JSDOM視為PhantomJS的輕量級替代品，因為JSDOM在後台沒有完整的瀏覽器。 它只專注於模擬記憶體中的DOM。

 這種方法的優點是設置速度快，速度快。
 也就是說，PhantomJS和JSDOM都是很好的選擇。
 **我們將使用Node中的JSDOM編寫我們的測試。**

- **73 Where do test files belong ?**

說很多兩者放在同一個資料夾的好處，就依照這樣的做法吧。

- **74 When should test run ?**

如果我們談論單元測試，答案很簡單。
**每次你 save 時，單元測試都應該運行。**
 這個快速反饋循環可確保您立即收到任何回歸通知。
 每次點擊保存時都會運行測試，這有助於測試驅動的開發，因為您可以通過點擊控件S快速看到您的測試從紅色變為綠色。
 如果您手動運行測試，會產生不必要的摩擦。
 當手動運行測試套件時，很容易忘記在進行更改後運行測試套件，因此請使其自動化並減少摩擦。
 我知道你在想什麼，但是每次我 save 時我都不能運行我的測試套件，這太慢了。
 我在這裡談論單元測試。 單元測試應該運行得非常快。
 集成測試也很有用，而且確實比較慢，所以您需要單獨運行這些測試。
 **但是你的單元測試應該很快，因為它們不應該打外部資源。**

 現在讓我回過頭來，澄清單元測試和集成測試之間的區別。 單元測試是關於單獨測試一個小單元的代碼。
 集成測試是關於測試多個項目的集成。
 因此，單元測試通常涉及單獨測試一個函數，而集成測試通常意味著啟動一個瀏覽器並使用像Selenium這樣的自動化工具點擊真實的UI，並經常對Web API進行實際調用，儘管您當然可以編寫集成例如，僅使用Node和JSDOM進行測試。

 由於單元測試試圖單獨測試一小部分代碼，所以它們運行速度非常快，足夠快，以至於每次保存時都應該能夠運行所有單元測試。
 相比之下，集成測試速度較慢，因為它們通常需要真正的外部資源，例如瀏覽器，Web API和數據庫，這些資源比原生函數調用花費更長的時間來啟動和響應。
 現在，由於單元測試運行速度很快，每次點擊保存時都應該運行它們
**如果單元測試的運行速度不夠快，無法在每次保存時重新運行，那往往表明它們並不是真正的單元測試。**

 但是由於集成測試通常與緩慢的外部資源相互作用
they're often run on demend or in QA.

---

### what does continuous integration do ?

那麼CI服務器如何提供所有這些好處？首先它會在您commit的時刻自動構建您的應用程序。
 這可以確保您的應用程序構建在另一台機器上。
 肯定會在幾小時或幾天之後擊敗所有常見的選擇，有人得到最新信息並抱怨有人破壞了構建。
 CI服務器通過檢查每個commit來清除誰破壞了構建。 它也運行你的測試套件。
你應該在commit之前運行你的測試，但CI服務器確保它始終發生，並確保測試通過多台機器。
 如果測試沒有通過，那麼你的commit有問題。
 因此，有一個單獨的服務器運行測試以確認它們不僅僅傳遞給您的計算機，這一點很重要。
 CI服務器可以運行代碼覆蓋率等任務，如果代碼覆蓋率低於指定閾值，則拒絕commit。
 最後，雖然不是必需的，但您甚至可以考慮使用CI服務器自動部署。
 在這種情況下，如果上述所有檢查都通過，則您的應用程序會自動部署到生產環境中。

**Travis 和 Jenkins 是最流行的，因此擁有最大的支持生態系統**
Travis 有一個託管解決方案，而 Jenkins 是一個不錯的選擇，如果你更喜歡自己託管你的CI服務器。 
Appveyor因其Windows支持而值得注意。
我們將設置兩個持續集成服務器，Travis CI和Appveyor。
因為Travis CI在Linux上運行，而Appveyor在Windows上運行。
 這意味著我們可以確信，我們的構建過程在Mac，Linux和Windows上運行。
 在我目前的團隊中，開發人員同時運行Mac和Windows，因此使用Travis CI和Appveyor有助於確保我們的構建可以在兩個平台上運行。

---

 ### HTTP call approaches

如果你只在Node上工作，使用 Request 
如果您在瀏覽器中，那麼使用 polyfill 進行抓取是最有前途的方法.但是，這也假定您可以忍受Fetch的限制。
**當您關心的所有瀏覽器都添加了對Fetch的支持時，您可以稍後完全刪除polyfill。**

最後，如果您正在構建需要在客戶端和服務器上呈現的應用程序，那麼
isomorphic-fetch
xhr
SuperAgent
Axios
都是不錯的選擇。取決於您是否優先考慮文件大小或功能，SuperAgent和Axios 提供更多功能。

### Why Mock HTTP ?

你想單元測試你的代碼，以便你的測試能夠快速可靠地運行
或者你的開發或QA環境中現有的Web服務調用起來很慢或者很昂貴。
 mock HTTP意味著你可以一直得到即時的回應。
**也許你需要在飛機上，在路上或連接不好的其他地方工作。 模擬允許您在離線狀態下繼續工作。**

 或者，也許現有的服務是不可靠的，即使在服務關閉的情況下，您也可以繼續使用模擬API。
 也許你還沒有創建任何Web服務。
 如果您還沒有決定如何設計您的Web服務，模擬可以讓您快速為不同的潛在 response 創建原型，並了解它們如何與您的應用程序配合使用。
 也許一個單獨的團隊正在為您的應用程序創建服務，通過 mock 服務調用，您可以立即開始編碼並在準備就緒時切換到實際的Web服務，您只需要就API提議的設計達成一致並相應地進行模擬最後

### How to Mock HTTP ?


      使用 JSON Server 
 JSON server 使用靜態JSON創建假數據庫，然後當您啟動 JSON server 時，它會創建一個Web服務，在後台使用靜態JSON，因此當您刪除，添加或編輯記錄時它實際上更新了文件。
 因此，這提供了一個真實工作API的完整模擬，但是針對本地模擬數據，它們只是坐在一個靜態文件中，這非常有用，因為該應用程序感覺完全響應，並且不必通過站立本地數據庫和Web服務器。

**如果你想使用動態數據而不是相同的硬編碼數據呢？**

    JSON Schema faker 會為您生成假數據。

 您可以指定您喜歡的數據類型，例如字符串，數字或布爾值，並且它會生成可以寫入文件的隨機數據。
 您可以指定各種設置，以確定其生成數據的方式，如數字範圍或創建真實姓名和電子郵件的有用生成器。
 最後，您可以全力以赴地使用您的開發Web服務器（如Browsersync或Express）自行連接虛擬API，當然，這是最多的工作，但它也為您提供最強大的功能。

    Static JSON: 

您的應用程序每次都會加載相同的數據，並且如果您嘗試以任何方式操作該數據，它將不會在重新加載時反映出來。
JSON Server: 實際上保存了您對數據所做的更改，因此它增加了您的模擬API的真實性。

    JSON Schema Faker + JSON Server 

使您的模擬API更具動態性，可以在您每次啟動應用程序時創建不同的假數據。
 這對於捕獲設計中的邊緣案例（例如分頁，溢出，排序和格式設置）非常有幫助，

    最後，Express之類的東西

從頭開始設置完整的模擬API，並使用填充了模擬數據的實時數據庫，當然可以讓您全部根據需要定制。

 但是如果你以後還沒有服務和數據庫，那麼在你享受快速的前端開發體驗之前，你需要做好所有這些努力。
 總之，如果已經有可用的服務層，那麼我建議使用它。
 但是如果一個單獨的團隊正在構建一個服務層，並且還沒有構建它，我建議嘗試一個模擬API，以便您可以快速移動而不依賴真實的API後端。

### our plan for mocking HTTP

1. 首先我們將使用JSON Schema Faker為我們的模擬API聲明模式，這將允許我們聲明我們的假API應該看起來像什麼，我們將聲明它將公開的對象和屬性，包括數據類型。
1. 第二步涉及生成隨機數據，JSON Schema Faker支持使用幾個開源庫生成隨機數據。
      - faker.js
      - chance.js
      - randexp.js
 faker和 chance 非常相似，這兩個庫都提供了各種各樣的函數來生成隨機數據，包括真實姓名，地址，電話號碼，電子郵件等等。 Randexp專注於基於正則表達式創建隨機數據。
3. JSON Server
 JSON Server的美妙之處在於它實際上支持創建，讀取，更新和刪除操作。
 這意味著要開始開發，我們只需要就我們想要的調用和這些調用應該返回的數據形狀達成一致。
 然後，UI團隊可以繼續前進，而無需等待服務團隊實際創建這些關聯的服務，每個人都可以編寫代碼到一個界面並在以後重新組合。

---
### Project Structure tips

    JS belongs in a .js File.

在進行Web開發時，一些人試圖簡單地在 html `script` tag 內聯JavaScript 檔案。
 但讓我們暫停一下，並考慮為什麼應該避免。
 有很多缺點。

**我失去了利用我們剛剛建立的所有優點的能力。**

 看，如果我這樣做，我該如何編寫自動化測試？我如何鏈接此代碼？我如何重用這個？ 如果我想使用ES6，TypeScript 或一些可以翻譯JavaScript的替代語言呢？如果我想通過使用ES6的 import 來明確我的代碼的依賴關係，該怎麼辦？你不能。

**通過將 script 與 html內聯，您將失去所有這些權力。**
**應該避免在html文件內聯編寫JavaScript。**

      請不要使用一些服務器端語言來生成JavaScript。

 來自Stack Overflow的這個例子讓我想為維護程序員哭泣哀悼。
 我們來考慮一下這裡的開發者體驗。
 所有的代碼都是相同的顏色。
 沒辦法自動選字。 您的編輯器無法突出顯示任何拼寫錯誤，因此直到運行時才會發現錯誤。 你不能享受我們在這個課程中努力工作的優點。

 然而，經常看到這種模式，因為剛接觸JavaScript的服務器端開發人員需要根據數據庫中的數據執行一些自定義邏輯。

 如果您需要代碼針對不同的用戶做出不同的響應，請將JSON從 servr 注入到您的應用程序中。

      inject JSON from the server into your applicaiton

      稱之為 Configuration Object Pattern.

避免動態生成JavaScript代碼。
而是動態生成JavaScript代碼可以使用的一些數據。
我們不生成自定義的C＃，Java，Ruby或Python等，只是為了給每個用戶動態提供自定義行為。
相反的，我們從數據庫中提取數據，並使用該數據來確定應該運行的邏輯。

    Consider organizing files by feature

在更大，更複雜的項目中，考慮按功能而不是文件類型進行組織。
 有兩種流行的方式來組織您的代碼：按文件類型或按功能。
 當按文件類型組織時，所有用於相同目的的文件都放在一起。
 在使用MVC框架時，這是一種流行的方法，通常期望您使用 model，view 和 controller 文件夾來組織您的應用程序。
 然而，這種方法的缺點是，你最終不得不繞過文件系統來打開和處理相關文件。

      Extract logic into "POJOs"

努力將盡可能多的邏輯提取到普通的舊JavaScript中。
 有些人會稱之為POJO。意思是簡單的舊JavaScript對象。

**Plain Old JavaScript Objects**

 Java和C＃開發人員會認識到這個術語，因為Java開發人員還使用術語POJO來描述內部具有純邏輯並且沒有框架特定問題的Java類。

 關鍵是，這些文件應該包含純粹的邏輯，而不是綁定到任何框架。
 在構建應用程序時，盡量在普通JavaScript中放置盡可能多的邏輯。

**例如，如果你在React中工作，你的大部分邏輯應該存在於React component 之外。**
 這使得您的邏輯易於測試，易於重用，並有助於最大限度地減少與所選框架的聯繫。
 這最大限度地減少了切換到不同框架的影響

 要查看此哲學的示例，[請查看GitHub上的React Slingshot入門工具包中的演示應用程序。](https://github.com/coryhouse/react-slingshot/tree/master/src/utils)
 您會看到，日期格式和核心計算等關鍵邏輯在名為utils的文件夾中以普通JavaScript進行處理。
 雖然這個項目使用React，但這些都是純粹的JavaScript函數，並不以任何方式與React綁定。


####總結一下。
 在您的開始套件中包含一個工作示例應用程序 (example app) 非常有幫助。
 這為每個人提供了目錄結構，文件命名，框架使用，測試，API調用，部署等方面的推薦方法。
 它提供了一個互動的例子，說明在團隊中工作的感覺。
 然後我們轉到幾個基本規則來構建您的項目。
 把你的JavaScript放在一個JavaScript文件中。
 這個原則是基礎性的。
 如果您將JavaScript與HTML內聯放置，您將失去我們在整個課程中努力設置的所有好處。
 考慮按功能組織您的演示應用程序，而不是技術或文件類型，特別是如果您的團隊通常構建大型且複雜的JavaScript應用程序。
 第三，將您的邏輯提取為普通的舊JavaScript對象。
 避免在框架特定的文件中嵌入太多的邏輯。
 將您的邏輯提取到易於測試的純函數。
使用您喜歡的 JavaScript框架和庫來構建您的演示應用程序。
 並且一定要選擇一個與您的業務相關的域名。

---
---





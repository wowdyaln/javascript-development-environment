- 025 - Demo - Sharing Work-in-progress
localtunnel 非常實用。如果您有一堆設備要與本地託管的工作進行對比，那麼將 **Browsersync** 與**localtunnel** 結合起來是一個非常有吸引力的組合。

  `npm install localtunnel -g`

---
- 032 - Demo - Concurrent Tasks
  - npm run all來並行執行在右側列出的所有任務
`npm start -s`

  - 為了方便起見，我想同時運行任務。我想要一個啟動Web服務器的命令，並通過本地通道共享我的工作，這樣我就不必像前一個模塊那樣手動打開兩個獨立的終端。
`npm run share`

---
- 41 why bundle?

NPM 使用 commonJS模式； node 可以處理這個，但瀏覽器不理解它。
 因此，您需要將NPM軟件包 bundle 到瀏覽器可以使用的格式中。
bundler 不僅僅適用於在瀏覽器中運行的應用程序。
 您可以使用 bundler 將任何 JavaScript 打包到單個文件中。
 或策略性地將其分成不同的文件，用於您應用的不同部分。
 想像一下你已經創建了一個包含五個獨立頁面的應用程序。
 一個強大的打包程序可以為每個頁面智能地創建單獨的JavaScript包。
 **這樣，用戶只需在初始加載時下載第一頁的相關JavaScript。**
 這可節省帶寬並加快頁面加載速度。
  - improve Node performance
bundler 不僅僅適用於Web。
 如果您在 node 中進行編碼，則可能需要使用捆綁器，因為 node 的 require很慢。 您可以編譯require請求，這通常可以提高性能。
我們先考慮JavaScript中提供的各種模塊格式，包括AMD，CommonJS，UMD和ES6模塊。

node.js 可以繼續使用CommonJS。
 但是，如果您在ES6或更新版本的JavaScript中工作，您終於可以享受ES6 module的強大功能。**而對於未來的應用開發，我們應該選擇ES6 module**。

---

- 049 - Sourcemaps

 一旦我們開始捆綁，縮小和編譯我們的代碼，我們就會產生一個新問題。
 當我們的代碼在瀏覽器中運行時，它變成了一個不可讀的混亂。
我該如何 debug ？另一個我們需要的重要工具：Sourcemaps。

生成一個源映射。Sourcemaps將捆綁，轉碼和縮小的代碼映射回原始源代碼。這意味著，當我們打開我們的瀏覽器開發工具並嘗試檢查我們的代碼時，我們會看到我們使用的原始ES6源代碼。這就像魔術一樣。源代碼可以作為我們構建過程的一部分自動生成。
您可能想知道如何縮小代碼實際上節省了任何帶寬，如果我們必須生成一個大的地圖回到原始來源。 源代碼的美妙之處在於，只有打開開發人員工具才能下載它們。
 因此，用戶甚至不會下載源代碼，但是在發生問題時，無論是在開發環境還是在生產環境中，它們都可供您使用。源代碼為您提供讀取原始代碼的所有好處，而不會給普通用戶帶來額外的成本。

 `devtool: 'inline-source-map'`
設置裡面這行，當我們在瀏覽器 debug， 可以看到原始碼，即使我們的代碼已經被轉換，捆綁和縮小之後。

---

- 63  why Lint via an automated build

您可能會想知道為什麼我們應該通過自動構建過程來 lint，因為許多編輯器都提供了ESLint集成內置的功能，所以他們只是監視您的代碼並在那裡輸出結果在編輯器內。我更願意將ESLint與我的構建過程集成在一起：首先，將我的代碼的所有反饋輸出到命令行，為我提供了一個地方來檢查與我的代碼質量相關的所有反饋。

 這意味著我有一個地方不僅可以查看linting問題，還可以查看任何編譯時錯誤或任何測試錯誤。
 **這對開發人員使用不同編輯器的團隊尤其有用。**
 我們都有相同的開發工作流程，因為我們都使用相同的入門工具包和命令行。
 如果每個人都有相同的開發流程，配對編程也更容易，而且最重要的是，ESLint應該是您的構建過程的一部分，以便在有人commit任何引發linting錯誤的代碼時，構建在持續集成服務器上被破壞。 這有助於防止您的應用程序慢慢變得不穩定。 即使開發人員在本地忽略ESLint，您的持續集成服務器也會自動拒絕構建。

---
- 70 Assertion library

許多測試框架如Jasmine和Jest都帶有內置的斷言。
 但是摩卡沒有提供斷言庫，所以我們必須選擇我們自己的。
 斷言庫之間的大多數選擇歸結為輕微的語法差異。
 最流行的斷言庫是Chai，但還有其他斷言庫，例如：Should.js ;  Expect。
 大多數框架都包含自己的內置斷言，但由於Mocha沒有，我們需要選擇一個。
 再一次，這些之間的核心區別是語法差異較小，所以不要花太多時間擔心這一點。
我們將使用Chai進行斷言，因為它很受歡迎，並提供了一系列斷言樣式可供選擇。

  - Helper library

在我們開始編寫測試之前，還有另一個問題需要回答。
 我們應該使用助手庫嗎？如果是這樣，哪一個？ 

    JSDOM是一個值得考慮的有趣的 library。
    JSDOM是您可以在Node中運行的瀏覽器DOM的實現。

 所以在JSDOM中，我們可以運行依賴於DOM的測試，而無需打開實際的瀏覽器。 這使得自動化測試的測試配置更簡單，並且通常意味著測試運行得更快。 所以當你想用Node編寫涉及HTML和瀏覽器交互的測試時，JSDOM很有用。

     Cheerio是值得一提的另一個有趣的library

 您可以將Cheerio視為服務器的jQuery。
 如果您使用JSDOM，這非常方便，因為您可以編寫測試來確定某個HTML是否符合您的期望。如果您了解jQuery，則您已經知道如何使用Cheerio，因為它使用jQuery選擇器來查詢DOM。 使用Cheerio，你可以使用jQuery的選擇器來查詢JSDOM的虛擬DOM。

 如果您已經了解jQuery，與編寫傳統的DOM查詢相比，這可以節省一些輸入。


- 72 Where to run test ?

 有三種流行的方法來運行基於JavaScript的測試。

       最明顯的選擇是在瀏覽器中運行我們的測試。
 Karma和Testem是流行的測試跑步者，用於在實際瀏覽器中進行測試。
 然而，打開一個實際的瀏覽器需要更多的配置，並且比替代選擇要慢，所以我寧願避免這種方法。


    我們可以使用像PhantomJS這樣的無頭瀏覽器來運行我們的測試。

 那麼什麼是無頭瀏覽器？無頭瀏覽器是沒有可見用戶界面的瀏覽器。
 PhantomJS是一個完全真實的瀏覽器，在後台運行V8 JavaScript引擎。
 但是你看不到PhantomJS，因為它沒有可見的界面。
 這很有用，因為經常編寫自動化測試你不需要看到實際的界面。 您只需要快速的模擬真實瀏覽器。

     第三種選擇是利用內存中的DOM。
 正如我們剛剛討論的，JSDOM是一個庫，它通過在我們可以與之交互的內存中創建一個DOM來模擬實際的瀏覽器。 您可以將JSDOM視為PhantomJS的輕量級替代品，因為JSDOM在後台沒有完整的瀏覽器。 它只專注於模擬內存中的DOM。

 這種方法的優點是設置速度快，速度快。
 也就是說，PhantomJS和JSDOM都是很好的選擇。
 **我們將使用Node中的JSDOM編寫我們的測試。**

- **73 Where do test files belong ?**

說很多兩者放在同一個資料夾的好處，就依照這樣的做法吧。

- **74 When should test run ?**

如果我們談論單元測試，答案很簡單。
**每次你 save 時，單元測試都應該運行。**
 這個快速反饋循環可確保您立即收到任何回歸通知。
 每次點擊保存時都會運行測試，這有助於測試驅動的開發，因為您可以通過點擊控件S快速看到您的測試從紅色變為綠色。
 如果您手動運行測試，會產生不必要的摩擦。
 當手動運行測試套件時，很容易忘記在進行更改後運行測試套件，因此請使其自動化並減少摩擦。
 我知道你在想什麼，但是每次我 save 時我都不能運行我的測試套件，這太慢了。
 我在這裡談論單元測試。 單元測試應該運行得非常快。
 集成測試也很有用，而且確實比較慢，所以您需要單獨運行這些測試。
 **但是你的單元測試應該很快，因為它們不應該打外部資源。**

 現在讓我回過頭來，澄清單元測試和集成測試之間的區別。 單元測試是關於單獨測試一個小單元的代碼。
 集成測試是關於測試多個項目的集成。
 因此，單元測試通常涉及單獨測試一個函數，而集成測試通常意味著啟動一個瀏覽器並使用像Selenium這樣的自動化工具點擊真實的UI，並經常對Web API進行實際調用，儘管您當然可以編寫集成例如，僅使用Node和JSDOM進行測試。

 由於單元測試試圖單獨測試一小部分代碼，所以它們運行速度非常快，足夠快，以至於每次保存時都應該能夠運行所有單元測試。
 相比之下，集成測試速度較慢，因為它們通常需要真正的外部資源，例如瀏覽器，Web API和數據庫，這些資源比原生函數調用花費更長的時間來啟動和響應。
 現在，由於單元測試運行速度很快，每次點擊保存時都應該運行它們
**如果單元測試的運行速度不夠快，無法在每次保存時重新運行，那往往表明它們並不是真正的單元測試。**

 但是由於集成測試通常與緩慢的外部資源相互作用
they're often run on demend or in QA.

---

- what does continuous integration do ?

那麼CI服務器如何提供所有這些好處？首先它會在您commit的時刻自動構建您的應用程序。
 這可以確保您的應用程序構建在另一台機器上。
 肯定會在幾小時或幾天之後擊敗所有常見的選擇，有人得到最新信息並抱怨有人破壞了構建。
 CI服務器通過檢查每個commit來清除誰破壞了構建。 它也運行你的測試套件。
你應該在commit之前運行你的測試，但CI服務器確保它始終發生，並確保測試通過多台機器。
 如果測試沒有通過，那麼你的commit有問題。
 因此，有一個單獨的服務器運行測試以確認它們不僅僅傳遞給您的計算機，這一點很重要。
 CI服務器可以運行代碼覆蓋率等任務，如果代碼覆蓋率低於指定閾值，則拒絕commit。
 最後，雖然不是必需的，但您甚至可以考慮使用CI服務器自動部署。
 在這種情況下，如果上述所有檢查都通過，則您的應用程序會自動部署到生產環境中。

Travis 和 Jenkins 是最流行的，因此擁有最大的支持生態系統
Travis 有一個託管解決方案，而 Jenkins 是一個不錯的選擇，如果你更喜歡自己託管你的CI服務器。 
Appveyor因其Windows支持而值得注意。
我們將設置兩個持續集成服務器，Travis CI和Appveyor。
因為Travis CI在Linux上運行，而Appveyor在Windows上運行。
 這意味著我們可以確信，我們的構建過程在Mac，Linux和Windows上運行。
 在我目前的團隊中，開發人員同時運行Mac和Windows，因此使用Travis CI和Appveyor有助於確保我們的構建可以在兩個平台上運行。

---

 - HTTP call approaches

如果你只在Node上工作，使用 Request 
如果您在瀏覽器中，那麼使用 polyfill 進行抓取是最有前途的方法.但是，這也假定您可以忍受Fetch的限制。

最後，如果您正在構建需要在客戶端和服務器上呈現的應用程序，那麼
isomorphic-fetch
xhr
SuperAgent
Axios
都是不錯的選擇。取決於您是否優先考慮文件大小或功能，SuperAgent和Axios 提供更多功能。

